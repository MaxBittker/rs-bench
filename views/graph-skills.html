<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Skill XP Benchmark</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<script>
  // Parse horizon from URL (default: 30m)
  const params = new URLSearchParams(window.location.search);
  const HORIZON = params.get('horizon') || '30m';
  const HORIZON_MINUTES = parseInt(HORIZON);  // e.g. 30 or 10
</script>
<script>
  // Synchronously load the data file for the selected horizon (works with file://)
  document.write('<script src="../results/skills-' + HORIZON + '/_data.js"></' + 'script>');
</script>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  html, body { height: 100%; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #fff;
    color: #1a1a1a;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    padding: 24px 32px;
  }
  .page-header { margin-bottom: 4px; }
  .page-header h1 {
    font-size: 22px;
    font-weight: 600;
    color: #1a1a1a;
  }
  .page-subtitle {
    font-size: 14px;
    color: #999;
    margin-bottom: 16px;
  }
  .page-description {
    font-size: 13px;
    color: #888;
    line-height: 1.6;
    max-width: 720px;
    margin-bottom: 20px;
  }
  .pill-toggle {
    display: inline-flex;
    margin-left: 16px;
    vertical-align: middle;
  }
  .pill-toggle button {
    padding: 4px 14px;
    background: #fff;
    border: 1px solid #ddd;
    color: #555;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    transition: all 0.15s;
    margin-left: -1px;          /* overlap borders so they don't double up */
    position: relative;
  }
  .pill-toggle button:first-child { border-radius: 6px 0 0 6px; margin-left: 0; }
  .pill-toggle button:last-child  { border-radius: 0 6px 6px 0; }
  .pill-toggle button.active {
    background: #1a1a1a;
    border-color: #1a1a1a;
    color: #fff;
    z-index: 1;                 /* active border draws on top of neighbors */
  }
  .pill-toggle button:hover:not(.active) { border-color: #999; color: #1a1a1a; z-index: 1; }

  /* Grid view */
  .grid-container {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 16px;
  }
  .grid-cell {
    border: 1px solid #e8e8e8;
    border-radius: 8px;
    padding: 12px;
    display: flex;
    flex-direction: column;
    height: 220px;
    overflow: visible;
  }
  .grid-cell-title {
    font-size: 13px;
    font-weight: 600;
    color: #333;
    margin-bottom: 4px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .grid-cell-title img {
    width: 18px;
    height: 18px;
  }
  .grid-cell canvas {
    flex: 1;
    min-height: 0;
  }

  /* Cumulative view */
  .cumulative-container {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  .cumulative-container canvas {
    width: 100% !important;
    max-width: 900px;
    height: 450px !important;
  }

  /* Trajectory steps */
  .traj-step.agent {
    color: #1a1a1a;
    font-size: 14px;
    line-height: 1.65;
    padding: 10px 0;
    white-space: pre-wrap;
  }
  .traj-step.agent + .traj-step.agent {
    border-top: 1px solid #f0f0f0;
  }
  .traj-tool-group {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    padding: 4px 0;
  }
  .traj-tool-chip {
    display: inline-block;
    font-family: monospace;
    font-size: 10px;
    color: #aaa;
    background: #f5f5f5;
    border-radius: 3px;
    padding: 1px 6px;
    line-height: 1.5;
  }

  /* Skill picker */
  .skill-picker-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 6px;
    padding: 20px 24px;
  }
  .skill-picker-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 10px;
    border: 1px solid #e8e8e8;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 500;
    color: #333;
    transition: border-color 0.15s, background 0.15s;
  }
  .skill-picker-item:hover {
    border-color: #999;
    background: #fafafa;
  }
  .skill-picker-item img {
    width: 16px;
    height: 16px;
  }
  .skill-picker-xp {
    margin-left: auto;
    font-size: 11px;
    font-weight: 400;
    color: #aaa;
  }

  /* Legend */
  .bottom-legend {
    display: flex;
    gap: 24px;
    padding: 16px 0 12px;
    flex-wrap: wrap;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #555;
    cursor: pointer;
  }
  .legend-item.hidden { opacity: 0.35; }
  .legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 2px;
    flex-shrink: 0;
  }

  /* Load section */
  .no-data {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #999;
    font-size: 15px;
  }
  .load-bar {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin-bottom: 12px;
  }
  .load-bar button {
    padding: 8px 18px;
    background: #fff;
    border: 1px solid #ddd;
    border-radius: 8px;
    color: #555;
    cursor: pointer;
    font-size: 13px;
    transition: background 0.2s, border-color 0.2s;
  }
  .load-bar button:hover { background: #f5f5f5; border-color: #999; }
  .drop-zone {
    max-width: 500px;
    margin: 0 auto;
    padding: 24px;
    border: 2px dashed #ddd;
    border-radius: 12px;
    text-align: center;
    color: #999;
    font-size: 14px;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
  }
  .drop-zone:hover, .drop-zone.dragover { border-color: #4285f4; background: #f0f6ff; }
  .drop-zone input { display: none; }
  .download-btn {
    position: absolute;
    top: 24px;
    right: 32px;
    background: none;
    border: none;
    cursor: pointer;
    color: #999;
    font-size: 18px;
    padding: 4px 8px;
  }
  .download-btn:hover { color: #333; }
</style>
</head>
<body>

<div class="page-header">
  <h1>Skill XP Benchmark
    <span class="pill-toggle" id="horizonToggle">
      <button data-horizon="10m" onclick="setHorizon('10m')">10 min</button>
      <button data-horizon="30m" onclick="setHorizon('30m')">30 min</button>
    </span>
    <span class="pill-toggle" id="viewToggle" style="display:none; margin-left:8px">
      <button data-view="cumulative" class="active" onclick="setView('cumulative')">Average</button>
      <button data-view="grid" onclick="setView('grid')">Grid</button>
    </span>
  </h1>
</div>
<p class="page-description" id="pageDescription"></p>
<button class="download-btn" onclick="downloadView()" title="Download as PNG">&#8681;</button>

<div id="gridContainer" class="grid-container" style="display:none"></div>
<div id="cumulativeContainer" class="cumulative-container" style="display:none"></div>
<!-- Trajectory modal -->
<div id="trajectoryModal" style="display:none; position:fixed; inset:0; z-index:1000; background:rgba(0,0,0,0.45); overflow:auto" onclick="if(event.target===this)closeTrajectory()">
  <div style="max-width:640px; margin:40px auto; background:#fff; border-radius:12px; box-shadow:0 8px 32px rgba(0,0,0,0.18); max-height:calc(100vh - 80px); display:flex; flex-direction:column">
    <div id="trajHeader" style="padding:16px 24px; border-bottom:1px solid #e8e8e8; flex-shrink:0">
      <div style="display:flex; justify-content:space-between; align-items:center">
        <h3 id="trajTitle" style="font-size:16px; font-weight:600; margin:0"></h3>
        <button onclick="closeTrajectory()" style="background:none; border:none; font-size:20px; cursor:pointer; color:#999; padding:0 4px">&times;</button>
      </div>
      <div id="trajSubtitle" style="font-size:12px; color:#999; margin-top:2px"></div>
    </div>
    <div id="trajSteps" style="padding:16px 24px; overflow-y:auto; flex:1"></div>
  </div>
</div>

<!-- Skill picker modal -->
<div id="skillPickerModal" style="display:none; position:fixed; inset:0; z-index:999; background:rgba(0,0,0,0.45); overflow:auto" onclick="if(event.target===this)closeSkillPicker()">
  <div style="max-width:520px; margin:80px auto; background:#fff; border-radius:12px; box-shadow:0 8px 32px rgba(0,0,0,0.18)">
    <div style="padding:16px 24px; border-bottom:1px solid #e8e8e8; display:flex; justify-content:space-between; align-items:center">
      <h3 id="skillPickerTitle" style="font-size:16px; font-weight:600; margin:0"></h3>
      <button onclick="closeSkillPicker()" style="background:none; border:none; font-size:20px; cursor:pointer; color:#999; padding:0 4px">&times;</button>
    </div>
    <div id="skillPickerGrid" class="skill-picker-grid"></div>
  </div>
</div>

<div id="loadSection">
  <div class="load-bar" id="loadBar">
    <button onclick="loadResults()" id="loadBtn">Load Results</button>
  </div>
  <div class="drop-zone" id="dropZone">
    <p>Drop _combined.json here or click to browse</p>
    <input type="file" id="fileInput" accept=".json">
  </div>
</div>

<div class="bottom-legend" id="bottomLegend"></div>

<script>
const MODEL_CONFIG = {
  'opus':     { displayName: 'Claude Opus 4.6',   shortName: 'Opus 4.6',    color: '#8b7355', order: 1, icon: 'model-icons/anthropic.svg' },
  'opus45':   { displayName: 'Claude Opus 4.5',   shortName: 'Opus 4.5',    color: '#a08060', order: 2, icon: 'model-icons/anthropic.svg' },
  'sonnet46': { displayName: 'Claude Sonnet 4.6', shortName: 'Sonnet 4.6',  color: '#d4442a', order: 3, icon: 'model-icons/anthropic.svg' },
  'sonnet45': { displayName: 'Claude Sonnet 4.5', shortName: 'Sonnet 4.5',  color: '#e07850', order: 4, icon: 'model-icons/anthropic.svg' },
  'gemini':   { displayName: 'Gemini 3 Pro',      shortName: 'Gemini 3',    color: '#4285f4', order: 5, icon: 'model-icons/gemini.webp' },
  'gemini31': { displayName: 'Gemini 3.1 Pro',    shortName: 'Gemini 3.1',  color: '#1a57c4', order: 6, icon: 'model-icons/gemini.webp' },
  'haiku':    { displayName: 'Claude Haiku 3.5',   shortName: 'Haiku 3.5',  color: '#e06090', order: 7, icon: 'model-icons/anthropic.svg' },
  'codex':    { displayName: 'Codex CLI 5.2',       shortName: 'Codex 5.2', color: '#10a37f', order: 8, icon: 'model-icons/openai.png' },
  'codex53':  { displayName: 'Codex CLI 5.3',       shortName: 'Codex 5.3', color: '#0d8c6b', order: 9, icon: 'model-icons/openai.png' },
  'glm':      { displayName: 'GLM 5',             shortName: 'GLM 5',       color: '#6c5ce7', order: 10, icon: 'model-icons/zai.png' },
  'kimi':     { displayName: 'Kimi K2.5',         shortName: 'Kimi K2.5',   color: '#00b4d8', order: 11, icon: 'model-icons/kimi.png' },
  'qwen3':    { displayName: 'Qwen3 Coder Next', shortName: 'Qwen3',       color: '#6366f1', order: 12, icon: 'model-icons/qwen.webp' },
};

const SKILL_ORDER = [
  'attack', 'defence', 'strength', 'hitpoints',
  'ranged', 'prayer', 'magic', 'woodcutting',
  'fishing', 'mining', 'cooking', 'fletching',
  'crafting', 'smithing', 'firemaking', 'thieving',
];

const SKILL_DISPLAY = {
  attack: 'Attack', defence: 'Defence', strength: 'Strength', hitpoints: 'Hitpoints',
  ranged: 'Ranged', prayer: 'Prayer', magic: 'Magic', woodcutting: 'Woodcutting',
  fishing: 'Fishing', mining: 'Mining', cooking: 'Cooking', fletching: 'Fletching',
  crafting: 'Crafting', smithing: 'Smithing', firemaking: 'Firemaking', thieving: 'Thieving',
};

let combinedData = {};
let currentView = 'cumulative';
let useLogScale = false;
let hiddenModels = new Set();
let gridCharts = [];
let cumulativeChart = null;

// Preload model icons as Image objects for canvas drawing
const modelIconImages = {};
let iconsLoaded = 0;
let iconTotal = 0;
function preloadIcons() {
  for (const [key, config] of Object.entries(MODEL_CONFIG)) {
    if (config.icon) {
      iconTotal++;
      const img = new Image();
      img.onload = () => {
        iconsLoaded++;
        // Once all icons are loaded, redraw all active charts
        if (iconsLoaded >= iconTotal) {
          for (const c of gridCharts) c.draw();
          if (cumulativeChart) cumulativeChart.draw();
        }
      };
      img.src = config.icon;
      modelIconImages[key] = img;
    }
  }
}
preloadIcons();

// ── Data loading ────────────────────────────────────────────────

function loadResults() {
  if (window.COMBINED_DATA) {
    combinedData = window.COMBINED_DATA;
    onDataLoaded();
  }
}

const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  for (const file of e.dataTransfer.files) {
    const reader = new FileReader();
    reader.onload = (ev) => {
      try { combinedData = JSON.parse(ev.target.result); onDataLoaded(); } catch {}
    };
    reader.readAsText(file);
  }
});
fileInput.addEventListener('change', e => {
  for (const file of e.target.files) {
    const reader = new FileReader();
    reader.onload = (ev) => {
      try { combinedData = JSON.parse(ev.target.result); onDataLoaded(); } catch {}
    };
    reader.readAsText(file);
  }
});

// ── UI ──────────────────────────────────────────────────────────

function onDataLoaded() {
  document.getElementById('loadSection').style.display = 'none';
  document.getElementById('viewToggle').style.display = '';
  renderLegend();
  renderCurrentView();
}

function setView(view) {
  currentView = view;
  document.querySelectorAll('#viewToggle button').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.view === view);
  });
  renderCurrentView();
}

function toggleModel(name) {
  if (hiddenModels.has(name)) hiddenModels.delete(name);
  else hiddenModels.add(name);
  renderLegend();
  renderCurrentView();
}

function getModelAvgXp(model) {
  const skills = combinedData[model];
  if (!skills) return 0;
  const xps = Object.values(skills).map(s => s.finalXp || 0);
  return xps.length ? xps.reduce((a, b) => a + b, 0) / xps.length : 0;
}

function getModelsInData() {
  return Object.keys(combinedData)
    .sort((a, b) => ((MODEL_CONFIG[a] || {order:99}).order) - ((MODEL_CONFIG[b] || {order:99}).order));
}

function getModelsByPerformance() {
  return Object.keys(combinedData)
    .sort((a, b) => getModelAvgXp(b) - getModelAvgXp(a));
}

function renderLegend() {
  const models = currentView === 'cumulative' ? getModelsByPerformance() : getModelsInData();
  const el = document.getElementById('bottomLegend');
  el.innerHTML = models.map(name => {
    const config = MODEL_CONFIG[name] || { displayName: name, color: '#999' };
    const isHidden = hiddenModels.has(name);
    const avgXp = getModelAvgXp(name);
    const avgStr = currentView === 'cumulative' && avgXp > 0 ? ` (${formatXp(avgXp)})` : '';
    return `<div class="legend-item ${isHidden ? 'hidden' : ''}" onclick="toggleModel('${name}')">
      <div class="legend-dot" style="background:${config.color}"></div>
      <span>${config.displayName}${avgStr}</span>
    </div>`;
  }).join('');
}

function renderCurrentView() {
  document.getElementById('gridContainer').style.display = 'none';
  document.getElementById('cumulativeContainer').style.display = 'none';

  if (currentView === 'grid') {
    document.getElementById('gridContainer').style.display = 'grid';
    renderGrid();
  } else if (currentView === 'cumulative') {
    document.getElementById('cumulativeContainer').style.display = 'flex';
    renderCumulative();
  }
}

// ── Sanitize XP data (filter out spurious drops to 0) ──────────

function sanitizePoints(points) {
  if (points.length < 3) return points;
  const result = [];
  for (let i = 0; i < points.length; i++) {
    const prev = i > 0 ? points[i - 1].y : 0;
    const next = i < points.length - 1 ? points[i + 1].y : points[i].y;
    // Skip if value drops to 0 but neighbors are non-zero (connection blip)
    if (points[i].y === 0 && prev > 0 && next > 0) continue;
    result.push(points[i]);
  }
  return result;
}

// ── Extract skill XP points from samples ────────────────────────

function extractSkillPoints(skillData, skill) {
  if (!skillData || !skillData.samples || skillData.samples.length === 0) return [];
  const skillNameCaps = SKILL_DISPLAY[skill] || skill;

  const points = [];
  for (const s of skillData.samples) {
    const x = s.elapsedMs / 60000;
    if (x > HORIZON_MINUTES) break;
    let xp = 0;
    if (s.skills) {
      for (const [sName, sData] of Object.entries(s.skills)) {
        if (sName.toLowerCase() === skillNameCaps.toLowerCase() ||
            sName.toLowerCase() === skill.toLowerCase()) {
          xp = sData.xp || 0;
          break;
        }
      }
    }
    points.push({ x, y: xp });
  }

  return sanitizePoints(points);
}

// ── Chart.js plugin: draw model icon at end of each line ────────

const endIconPlugin = {
  id: 'endIcon',
  afterDraw(chart) {
    const ctx = chart.ctx;
    const size = 14;
    const labelGap = 3;
    const minSpacing = 12; // minimum vertical pixels between labels

    // Collect all visible label positions
    const labels = [];
    for (const dataset of chart.data.datasets) {
      if (!dataset._modelKey) continue;
      const meta = chart.getDatasetMeta(chart.data.datasets.indexOf(dataset));
      if (!meta.visible) continue;
      const elements = meta.data;
      if (elements.length === 0) continue;
      const last = elements[elements.length - 1];
      if (!last) continue;

      const config = MODEL_CONFIG[dataset._modelKey] || { shortName: dataset._modelKey, color: '#999' };
      labels.push({
        x: last.x,
        y: last.y,
        drawY: last.y, // will be adjusted for overlap
        modelKey: dataset._modelKey,
        name: config.shortName || config.displayName,
        color: config.color,
      });
    }

    // Sort by y position and push apart overlapping labels
    labels.sort((a, b) => a.y - b.y);
    for (let i = 1; i < labels.length; i++) {
      const gap = labels[i].drawY - labels[i - 1].drawY;
      if (gap < minSpacing) {
        labels[i].drawY = labels[i - 1].drawY + minSpacing;
      }
    }

    // Draw icons and labels
    for (const label of labels) {
      const icon = modelIconImages[label.modelKey];
      ctx.save();
      ctx.globalAlpha = 0.9;
      if (icon && icon.complete) {
        ctx.drawImage(icon, label.x - size / 2, label.y - size / 2, size, size);
      }
      ctx.font = '10px -apple-system, BlinkMacSystemFont, sans-serif';
      ctx.fillStyle = label.color;
      ctx.textBaseline = 'middle';
      ctx.fillText(label.name, label.x + size / 2 + labelGap, label.drawY);
      ctx.restore();
    }
  }
};

Chart.register(endIconPlugin);

// ── Grid View ───────────────────────────────────────────────────

function renderGrid() {
  for (const c of gridCharts) c.destroy();
  gridCharts = [];

  const container = document.getElementById('gridContainer');
  container.innerHTML = '';

  const models = getModelsInData().filter(m => !hiddenModels.has(m));

  for (const skill of SKILL_ORDER) {
    const cell = document.createElement('div');
    cell.className = 'grid-cell';

    const title = document.createElement('div');
    title.className = 'grid-cell-title';
    const iconSrc = 'skill-icons/' + skill + '.png';
    title.innerHTML = `<img src="${iconSrc}" onerror="this.style.display='none'">${SKILL_DISPLAY[skill] || skill}`;
    cell.appendChild(title);

    const canvas = document.createElement('canvas');
    cell.appendChild(canvas);
    container.appendChild(cell);

    const datasets = [];
    for (const model of models) {
      const points = extractSkillPoints(combinedData[model]?.[skill], skill);
      if (points.length === 0) continue;

      const config = MODEL_CONFIG[model] || { displayName: model, color: '#999' };

      datasets.push({
        label: config.displayName,
        data: points,
        borderColor: config.color,
        backgroundColor: config.color,
        fill: false,
        pointRadius: 0,
        pointHoverRadius: 3,
        borderWidth: 1.5,
        tension: 0.3,
        _modelKey: model,
      });
    }

    const chart = new Chart(canvas, {
      type: 'line',
      data: { datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        layout: { padding: { top: 8, right: 110, bottom: 2 } },
        interaction: { mode: 'nearest', intersect: false },
        onClick: (event, elements) => {
          if (elements.length > 0) {
            const ds = datasets[elements[0].datasetIndex];
            if (ds._modelKey) openTrajectory(ds._modelKey, skill);
          }
        },
        scales: {
          x: {
            type: 'linear',
            min: 0,
            max: HORIZON_MINUTES,
            ticks: { color: '#bbb', font: { size: 10 }, maxTicksLimit: 4 },
            grid: { color: '#f0f0f0', drawTicks: false },
            border: { color: '#e0e0e0' },
            title: { display: false },
          },
          y: {
            min: 0,
            ticks: {
              color: '#bbb',
              font: { size: 10 },
              maxTicksLimit: 5,
              callback: v => v >= 1000 ? (v / 1000).toFixed(0) + 'k' : v,
            },
            grid: { color: '#f0f0f0', drawTicks: false },
            border: { color: '#e0e0e0' },
          },
        },
        plugins: {
          legend: { display: false },
          tooltip: {
            enabled: true,
            callbacks: {
              title: items => items[0] ? `${items[0].parsed.x.toFixed(1)} min` : '',
              label: item => `${item.dataset.label}: ${item.parsed.y.toLocaleString()} XP`,
            },
          },
        },
      },
    });
    canvas.style.cursor = 'pointer';
    gridCharts.push(chart);
  }
}

// ── Cumulative Average View ─────────────────────────────────────

// Store per-model skill datasets for hover reveal
let cumulativeSkillDatasets = {}; // model -> [{label, data, color}, ...]
let cumulativeSkillFinalXp = {}; // model -> [{skill, label, finalXp}, ...] sorted desc

function renderCumulative() {
  if (cumulativeChart) { cumulativeChart.destroy(); cumulativeChart = null; }
  cumulativeSkillDatasets = {};
  cumulativeSkillFinalXp = {};

  const container = document.getElementById('cumulativeContainer');
  container.innerHTML = '';

  const canvas = document.createElement('canvas');
  container.appendChild(canvas);

  const models = getModelsInData().filter(m => !hiddenModels.has(m));
  const datasets = [];

  // For each model, average XP across all 16 skills at each time bucket (1 min intervals)
  const BUCKET_COUNT = HORIZON_MINUTES + 1;

  for (const model of models) {
    const config = MODEL_CONFIG[model] || { displayName: model, color: '#999' };
    const bucketSums = new Array(BUCKET_COUNT).fill(0);
    const bucketCounts = new Array(BUCKET_COUNT).fill(0);

    // Collect individual skill curves for hover reveal
    const skillCurves = [];

    for (const skill of SKILL_ORDER) {
      const points = extractSkillPoints(combinedData[model]?.[skill], skill);
      if (points.length === 0) continue;

      // Bucket this skill's points
      const skillBuckets = [];
      for (let min = 0; min < BUCKET_COUNT; min++) {
        let lastXp = 0;
        for (const p of points) {
          if (p.x <= min) lastXp = p.y;
          else break;
        }
        bucketSums[min] += lastXp;
        bucketCounts[min]++;
        skillBuckets.push({ x: min, y: lastXp });
      }

      skillCurves.push({
        label: SKILL_DISPLAY[skill] || skill,
        data: skillBuckets,
      });
    }

    cumulativeSkillDatasets[model] = skillCurves;

    // Build sorted skill final XP list for tooltip
    const skillFinals = [];
    for (const skill of SKILL_ORDER) {
      const sd = combinedData[model]?.[skill];
      if (sd) skillFinals.push({ skill, label: SKILL_DISPLAY[skill] || skill, finalXp: sd.finalXp || 0 });
    }
    skillFinals.sort((a, b) => b.finalXp - a.finalXp);
    cumulativeSkillFinalXp[model] = skillFinals;

    const avgPoints = [];
    for (let min = 0; min < BUCKET_COUNT; min++) {
      if (bucketCounts[min] > 0) {
        avgPoints.push({ x: min, y: Math.round(bucketSums[min] / bucketCounts[min]) });
      }
    }

    datasets.push({
      label: config.displayName,
      data: avgPoints,
      borderColor: config.color,
      backgroundColor: config.color,
      fill: false,
      pointRadius: 0,
      pointHoverRadius: 4,
      borderWidth: 2.5,
      tension: 0.3,
      _modelKey: model,
      _isAverage: true,
    });
  }

  // Plugin: draw individual skill lines at 50% opacity when hovering a model
  const skillOverlayPlugin = {
    id: 'skillOverlay',
    afterDatasetsDraw(chart) {
      if (!chart._hoveredModel) return;
      const model = chart._hoveredModel;
      const curves = cumulativeSkillDatasets[model];
      if (!curves) return;
      const config = MODEL_CONFIG[model] || { color: '#999' };
      const ctx = chart.ctx;
      const xScale = chart.scales.x;
      const yScale = chart.scales.y;

      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = config.color;
      ctx.lineWidth = 1.2;

      for (const curve of curves) {
        ctx.beginPath();
        let started = false;
        for (const pt of curve.data) {
          const px = xScale.getPixelForValue(pt.x);
          const py = yScale.getPixelForValue(pt.y);
          if (!started) { ctx.moveTo(px, py); started = true; }
          else ctx.lineTo(px, py);
        }
        ctx.stroke();
      }
      ctx.restore();
    }
  };

  cumulativeChart = new Chart(canvas, {
    type: 'line',
    data: { datasets },
    plugins: [skillOverlayPlugin],
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      layout: { padding: { top: 10, right: 120, bottom: 2 } },
      interaction: { mode: 'nearest', intersect: false },
      onClick: (event, elements) => {
        if (elements.length > 0) {
          const ds = datasets[elements[0].datasetIndex];
          if (ds._modelKey) openSkillPicker(ds._modelKey);
        }
      },
      onHover: (event, elements, chart) => {
        const prev = chart._hoveredModel;
        if (elements.length > 0) {
          const ds = chart.data.datasets[elements[0].datasetIndex];
          chart._hoveredModel = ds._modelKey || null;
        } else {
          chart._hoveredModel = null;
        }
        if (chart._hoveredModel !== prev) chart.draw();
      },
      scales: {
        x: {
          type: 'linear',
          min: 0,
          max: HORIZON_MINUTES,
          ticks: { color: '#999', font: { size: 11 }, stepSize: HORIZON_MINUTES <= 10 ? 2 : 5, callback: v => v + ' min' },
          grid: { color: '#f0f0f0', drawTicks: false },
          border: { color: '#e0e0e0' },
          title: { display: true, text: 'Elapsed Time', color: '#999', font: { size: 12 } },
        },
        y: {
          min: 0,
          ticks: {
            color: '#999',
            font: { size: 11 },
            maxTicksLimit: 8,
            callback: v => v >= 1000 ? (v / 1000).toFixed(0) + 'k' : v,
          },
          grid: { color: '#f0f0f0', drawTicks: false },
          border: { color: '#e0e0e0' },
          title: { display: true, text: 'Average XP per Skill', color: '#999', font: { size: 12 } },
        },
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          enabled: true,
          displayColors: false,
          bodyFont: { size: 11 },
          titleFont: { size: 12, weight: 'bold' },
          padding: 10,
          callbacks: {
            title: items => {
              if (!items[0]) return '';
              const ds = items[0].dataset;
              return `${ds.label} — ${items[0].parsed.x} min`;
            },
            label: item => {
              const modelKey = item.dataset._modelKey;
              const lines = [`Avg: ${item.parsed.y.toLocaleString()} XP`, ''];
              const skills = cumulativeSkillFinalXp[modelKey] || [];
              for (const s of skills) {
                lines.push(`${s.label}: ${formatXp(s.finalXp)}`);
              }
              return lines;
            },
          },
        },
      },
    },
  });
}

// ── Skill Picker (from cumulative view) ─────────────────────────

function openSkillPicker(model) {
  const config = MODEL_CONFIG[model] || { displayName: model, color: '#999' };
  document.getElementById('skillPickerTitle').textContent = config.displayName;

  const grid = document.getElementById('skillPickerGrid');
  let html = '';
  for (const skill of SKILL_ORDER) {
    const sd = combinedData[model]?.[skill];
    const xp = sd?.finalXp || 0;
    const hasTraj = sd?.trajectory?.length > 0;
    const iconSrc = 'skill-icons/' + skill + '.png';
    html += `<div class="skill-picker-item${hasTraj ? '' : ' no-traj'}" onclick="${hasTraj ? `closeSkillPicker();openTrajectory('${model}','${skill}')` : ''}" style="${hasTraj ? '' : 'opacity:0.4;cursor:default'}">
      <img src="${iconSrc}" onerror="this.style.display='none'">
      ${SKILL_DISPLAY[skill] || skill}
      <span class="skill-picker-xp">${xp > 0 ? formatXp(xp) : '-'}</span>
    </div>`;
  }
  grid.innerHTML = html;
  document.getElementById('skillPickerModal').style.display = 'block';
  document.body.style.overflow = 'hidden';
}

function closeSkillPicker() {
  document.getElementById('skillPickerModal').style.display = 'none';
  document.body.style.overflow = '';
}

// ── Trajectory Viewer ────────────────────────────────────────────

function openTrajectory(model, skill) {
  const data = combinedData[model]?.[skill];
  if (!data) return;

  const config = MODEL_CONFIG[model] || { displayName: model, color: '#999' };
  const skillName = SKILL_DISPLAY[skill] || skill;

  document.getElementById('trajTitle').textContent = `${config.displayName} — ${skillName}`;
  document.getElementById('trajSubtitle').textContent =
    `${formatXp(data.finalXp)} XP (Lv ${data.finalLevel}) · ${data.jobName || ''}`;

  // Steps — group consecutive tool calls into chip rows
  const stepsEl = document.getElementById('trajSteps');
  const steps = data.trajectory || [];
  if (steps.length === 0) {
    stepsEl.innerHTML = '<div style="color:#999; text-align:center; padding:32px">No trajectory data available for this run.</div>';
  } else {
    let html = '';
    let toolBuffer = [];

    function flushTools() {
      if (toolBuffer.length === 0) return;
      html += '<div class="traj-tool-group">';
      for (const t of toolBuffer) {
        // Shorten common tool prefixes for readability
        const label = t.replace(/^mcp__rs-agent__/, '').replace(/^mcp__\w+__/, '');
        html += `<span class="traj-tool-chip">${escapeHtml(label)}</span>`;
      }
      html += '</div>';
      toolBuffer = [];
    }

    for (const step of steps) {
      if (step.source === 'tool') {
        toolBuffer.push(step.text);
      } else {
        flushTools();
        html += `<div class="traj-step agent">${escapeHtml(step.text)}</div>`;
      }
    }
    flushTools();
    stepsEl.innerHTML = html;
  }

  document.getElementById('trajectoryModal').style.display = 'block';
  document.body.style.overflow = 'hidden';
}

function closeTrajectory() {
  document.getElementById('trajectoryModal').style.display = 'none';
  document.body.style.overflow = '';
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Close modals on Escape
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    closeTrajectory();
    closeSkillPicker();
  }
});

// ── Helpers ─────────────────────────────────────────────────────

function formatXp(xp) {
  if (xp >= 1_000_000) return (xp / 1_000_000).toFixed(1) + 'M';
  if (xp >= 1_000) return (xp / 1_000).toFixed(1) + 'k';
  return String(xp);
}

function hexToRgba(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}

function downloadView() {
  if (currentView === 'grid' && gridCharts.length > 0) {
    const link = document.createElement('a');
    link.download = 'skill-xp-benchmark-grid.png';
    link.href = gridCharts[0].canvas.toDataURL('image/png', 1.0);
    link.click();
  } else if (currentView === 'cumulative' && cumulativeChart) {
    const link = document.createElement('a');
    link.download = 'skill-xp-benchmark-average.png';
    link.href = cumulativeChart.canvas.toDataURL('image/png', 1.0);
    link.click();
  }
}

// ── Horizon switching ────────────────────────────────────────────

function setHorizon(h) {
  if (window.location.protocol === 'file:') {
    // file:// URLs don't support searchParams; rebuild manually
    const base = window.location.pathname;
    window.location = base + '?horizon=' + h;
  } else {
    const url = new URL(window.location);
    url.searchParams.set('horizon', h);
    window.location = url;
  }
}

// Mark the active horizon button
document.querySelectorAll('#horizonToggle button').forEach(btn => {
  btn.classList.toggle('active', btn.dataset.horizon === HORIZON);
});

// Set dynamic title/subtitle based on horizon
document.title = `Skill XP Benchmark (${HORIZON_MINUTES} min)`;
document.getElementById('pageDescription').textContent =
  `Each agent is placed in a RuneScape private server (8x game speed) and given ${HORIZON_MINUTES} minutes to maximize XP in a single skill. ` +
  `The agent controls a freshly-created character via writing and running TypeScript scripts against RS-SDK. `;

// Auto-load on page open
loadResults();
</script>
</body>
</html>
